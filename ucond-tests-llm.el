;;; ucond-tests-llm.el --- More tests for ucond.el -*- lexical-binding: t -*-

;; Copyright (C) 2025 Zhuyang Wang

;;; Commentary:
;;
;; This file is generated by Gemini CLI with model gemini-2.5-pro.
;; Many tests failed and were corrected by the author manually, but
;; the inline comments remained intact, so they might be inaccurate.
;;
;; This file contains more complex, deeply nested, and compound test
;; cases for ucond.el, generated to complement the existing unit
;; tests.

;;; Code:

(require 'ert)
(require 'ucond)

(ert-deftest ucond-tests-llm-deeply-nested-logic ()
  "Test a deeply nested ucond with fall-through and :otherwise."
  (should (equal (ucond
                  (let* ((x 1) (y 2)))
                  ;; This match* fails, so its inner ucond is skipped.
                  (match* (((guard (> x 5)) t))
                    :and-ucond
                    (let* ((z 3)) :otherwise (error "Should not be reached"))
                    (t 'inner-a))
                  ;; This match* succeeds.
                  (match* (((guard (= x 1)) t))
                    :and-ucond
                    ;; The inner ucond starts executing.
                    (let* ((y 3))) ; y is now 3 locally.
                    ;; This when fails.
                    (when (= y 2))
                    ;; This let* fails and triggers :otherwise, exiting the entire ucond.
                    (let* (((guard (= y 4)) t)) :otherwise 'inner-c)
                    ;; This should not be reached.
                    (t (error "Should not be reached")))
                  ;; This is the fall-through case if the above match* didn't produce a value.
                  (t 'outer-d))
                 'outer-d)))

(ert-deftest ucond-tests-llm-complex-fallthrough-and-bindings ()
  "Test how bindings from outer scopes are handled in nested fall-through."
  (should (equal (ucond
                  (let* ((status "pending")))
                  ;; First ucond block, which will fail entirely and fall through.
                  (ucond
                   (let* ((status "running")))
                   (when (string= status "running"))
                   ;; This let* fails, so this inner ucond will fall through.
                   (let* (((guard (string= status "error")) t))))
                  ;; Second ucond block, which will succeed.
                  (ucond
                   (when (string= status "pending"))
                   (let* ((status "success")))
                   (ucase status
                     ("success" 'finished)
                     (_ 'unknown)))
                  (t 'fallback))
                 'finished)))

(ert-deftest ucond-tests-llm-intricate-ucase-with-nested-ucond ()
  "Test a complex ucase that contains a nested ucond."
  (let ((data (list 'user "test" (list :role "admin" :level 5))))
    (should (equal (ucase data
                     ;; This pattern fails.
                     (`(system ,_) 'system-call)
                     ;; This pattern matches, binding `name` and `props`.
                     (`(user ,name ,props)
                      :and-ucond
                      (let* ((level (plist-get props :level))))
                      (ucase (plist-get props :role)
                        ("guest" 'guest-access)
                        ;; This pattern matches.
                        ("admin"
                         :and-ucond
                         ((> level 3)
                          (concat "Welcome admin " name "!")))))
                     ;; Fallback, should not be reached.
                     (_ 'invalid-data))
                   "Welcome admin test!"))))

(ert-deftest ucond-tests-llm-nested-let-else-interaction ()
  "Test interaction between a failing nested let* (:otherwise) and outer clauses."
  (should (equal (ucond
                  (let* ((x 10)))
                  ;; This match* succeeds and enters the nested ucond.
                  (match* (((guard (> x 5)) t))
                    :and-ucond
                    (let* ((y 20)))
                    ;; This nested let* fails, and its :otherwise provides the
                    ;; final value for the entire expression.
                    (let* (((guard (< y 15)) t)) :otherwise 'y-is-not-small)
                    (t 'should-not-reach-this))
                  ;; This clause is never reached because the one above produced a value.
                  (t 'should-not-reach-this-either))
                 'y-is-not-small)))

(ert-deftest ucond-tests-llm-multiple-levels-of-ucase-and-ucond ()
  "Test multiple levels of nesting with both ucase and ucond."
  (let ((request `(:method "POST" :body (:type "json" :content "data"))))
    (should (equal
             (ucase request
               (`(:method "GET") "get-request")
               ;; This matches.
               (`(:method "POST" :body ,body)
                :and-ucase body
                ;; This matches.
                (`(:type "json" :content ,content)
                 :and-ucond
                 (let* ((c "data")))
                 (when (string= content c))
                 (let* ((status "processed")))
                 (t status))
                (`(:type "xml") "xml-content"))
               (_ "unknown-request"))
             "processed"))))

(ert-deftest ucond-tests-llm-correct-when-usage-with-otherwise ()
  "Test the correct use of `when' with an :otherwise clause."
  (should (equal (ucond
                  (let* ((x 5)))
                  ;; This `when' is false, so the :otherwise clause is executed.
                  (when (> x 10) :otherwise 'x-not-greater-than-10)
                  ;; This clause is never reached.
                  (t 'should-not-reach))
                 'x-not-greater-than-10))
  (should (equal (ucond
                  (let* ((x 15)))
                  ;; This `when' is true, so execution proceeds to the next clause.
                  (when (> x 10))
                  ;; This clause is executed.
                  (t 'x-is-greater-than-10))
                 'x-is-greater-than-10)))

(ert-deftest ucond-tests-llm-when-vs-condition-clause ()
  "Demonstrate the difference between a `when' clause and a (CONDITION...BODY) clause."
  ;; Using `when', which guards subsequent clauses.
  (should (equal (ucond
                  (let* ((status "active")))
                  (when (string= status "active"))
                  ('status-is-active))
                 'status-is-active))
  ;; Using a (CONDITION...BODY) clause, which is self-contained.
  (should (equal (ucond
                  (let* ((status "active")))
                  ((string= status "active") 'status-is-active))
                 'status-is-active)))

(ert-deftest ucond-tests-llm-when-with-fallthrough-on-failure ()
  "Test that a failing `when' without :otherwise causes a fall-through."
  (should (equal (ucond
                  (let* ((a 1) (b 2)))
                  ;; This nested ucond will be entered.
                  (ucond
                   ;; This `when' is false and has no :otherwise,
                   ;; so it should fall through from the inner ucond.
                   (when (= a b))
                   ;; This clause is never reached.
                   (t 'inner-should-not-be-reached))
                  ;; Execution continues in the outer ucond.
                  (t 'fell-through-correctly))
                 'fell-through-correctly)))

(ert-deftest ucond-tests-llm-complex-pcase-and-let-else ()
  "Test a failing pcase in a let* with an :otherwise branch."
  (should (equal (ucond
                  (let* ((config `(:type "xml" :data "<data/>"))))
                  ;; This let* fails because the :type is not "json".
                  (let* ((`(:type "json" :data ,d) config))
                    :otherwise 'wrong-type)
                  ;; This clause is never reached.
                  (t 'should-not-reach))
                 'wrong-type)))

(ert-deftest ucond-tests-llm-nested-fallthrough-with-bindings ()
  "Test that bindings are preserved after a nested fall-through."
  (should (equal (ucond
                  (let* ((user-level 5) (request-type "admin")))
                  ;; This match* succeeds and enters the nested ucond.
                  (match* (((guard (string= request-type "admin")) t))
                    :and-ucond
                    ;; This inner match* fails because user-level is not > 10.
                    (match* (((guard (> user-level 10)) t))
                      'grant-super-admin-access)
                    ;; The inner ucond fails, so we fall through to the outer scope.
                    )
                  ;; This clause is executed after the fall-through.
                  ;; The `user-level` binding is still available.
                  ((> user-level 3)
                   'grant-admin-access)
                  (t 'fallback))
                 'grant-admin-access)))

(provide 'ucond-tests-llm)

;;; ucond-tests-llm.el ends here
